/* (C) Stefan John / Stenway / ReliableTXT.com / 2023 */
import * as fs from 'node:fs';
import { NoReliableTxtPreambleError, ReliableTxtDecoder, ReliableTxtDocument, ReliableTxtEncoder, ReliableTxtEncoding, ReliableTxtEncodingUtil, ReliableTxtLines, Utf16String } from '@stenway/reliabletxt';
// ----------------------------------------------------------------------
export class SyncReliableTxtFileHandle {
    get isClosed() {
        return this.handle === null;
    }
    get canRead() {
        return this.mode === 0 || this.mode === 2;
    }
    get canWrite() {
        return this.mode === 1 || this.mode === 2;
    }
    constructor(handle, encoding, mode, existing) {
        this.handle = handle;
        this.encoding = encoding;
        this.mode = mode;
        this.preambleSize = ReliableTxtEncodingUtil.getPreambleSize(this.encoding);
        this.existing = existing;
    }
    getSize() {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        return fs.fstatSync(this.handle).size;
    }
    getIsEmpty() {
        const size = this.getSize();
        return size === this.preambleSize;
    }
    getAllBytes() {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canRead) {
            throw new Error(`Not a reader`);
        }
        const fileSize = this.getSize();
        const buffer = new Uint8Array(fileSize);
        const numBytesRead = fs.readSync(this.handle, buffer, 0, fileSize, 0);
        if (numBytesRead !== fileSize) {
            throw new Error(`File was not fully read`);
        }
        return buffer;
    }
    getDocument() {
        const bytes = this.getAllBytes();
        return ReliableTxtDecoder.decode(bytes);
    }
    appendText(text) {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canWrite) {
            throw new Error(`Not a writer`);
        }
        const fileSize = this.getSize();
        const bytes = ReliableTxtEncoder.encodePart(text, this.encoding);
        const numBytesWritten = fs.writeSync(this.handle, bytes, 0, bytes.length, fileSize);
        if (numBytesWritten !== bytes.length) {
            throw new Error(`Text was not fully written`);
        }
    }
    readBytes(buffer, offset, length, position = null) {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canRead) {
            throw new Error(`Not a reader`);
        }
        return fs.readSync(this.handle, buffer, offset, length, position);
    }
    truncate(goalLength) {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canWrite) {
            throw new Error(`Not a writer`);
        }
        if (goalLength < this.preambleSize) {
            throw new Error("New file length cannot be smaller than the preamble size");
        }
        fs.ftruncateSync(this.handle, goalLength);
    }
    close() {
        if (this.handle !== null) {
            fs.closeSync(this.handle);
            this.handle = null;
        }
    }
    static createReader(filePath) {
        const handle = fs.openSync(filePath, "r");
        try {
            const encoding = this.getEncodingOrNull(handle);
            if (encoding === null) {
                throw new NoReliableTxtPreambleError();
            }
            return new SyncReliableTxtFileHandle(handle, encoding, 0, true);
        }
        catch (error) {
            fs.closeSync(handle);
            throw error;
        }
    }
    static createWriter(filePath, encoding = ReliableTxtEncoding.Utf8, overwriteExisting = true) {
        const handle = fs.openSync(filePath, overwriteExisting ? "w" : "wx");
        try {
            const preambleBytes = ReliableTxtEncodingUtil.getPreambleBytes(encoding);
            const numBytesWritten = fs.writeSync(handle, preambleBytes, 0, preambleBytes.length, 0);
            if (numBytesWritten !== preambleBytes.length) {
                throw new Error(`Preamble was not fully written`);
            }
            return new SyncReliableTxtFileHandle(handle, encoding, 1, false);
        }
        catch (error) {
            fs.closeSync(handle);
            throw error;
        }
    }
    static createAppender(filePath, createWithEncoding = ReliableTxtEncoding.Utf8) {
        try {
            const handle = fs.openSync(filePath, "r+");
            try {
                const encoding = this.getEncodingOrNull(handle);
                if (encoding === null) {
                    throw new NoReliableTxtPreambleError();
                }
                return new SyncReliableTxtFileHandle(handle, encoding, 2, true);
            }
            catch (error) {
                fs.closeSync(handle);
                throw error;
            }
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (error.code === "ENOENT") {
                return this.createWriter(filePath, createWithEncoding, false);
            }
            else {
                throw error;
            }
        }
    }
    static getEncodingOrNull(handle) {
        let buffer = new Uint8Array(4);
        const numBytesRead = fs.readSync(handle, buffer, 0, 4, 0);
        buffer = buffer.slice(0, numBytesRead);
        return ReliableTxtDecoder.getEncodingOrNull(buffer);
    }
}
// ----------------------------------------------------------------------
export class ReliableTxtFileHandle {
    get isClosed() {
        return this.handle === null;
    }
    get canRead() {
        return this.mode === 0 || this.mode === 2;
    }
    get canWrite() {
        return this.mode === 1 || this.mode === 2;
    }
    constructor(handle, encoding, mode, existing) {
        this.handle = handle;
        this.encoding = encoding;
        this.mode = mode;
        this.preambleSize = ReliableTxtEncodingUtil.getPreambleSize(this.encoding);
        this.existing = existing;
    }
    async getSize() {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        const stats = await this.handle.stat();
        return stats.size;
    }
    async getIsEmpty() {
        const size = await this.getSize();
        return size === this.preambleSize;
    }
    async getAllBytes() {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canRead) {
            throw new Error(`Not a reader`);
        }
        const fileSize = await this.getSize();
        const buffer = new Uint8Array(fileSize);
        const result = await this.handle.read(buffer, 0, fileSize, 0);
        if (result.bytesRead !== fileSize) {
            throw new Error(`File was not fully read`);
        }
        return buffer;
    }
    async getDocument() {
        const bytes = await this.getAllBytes();
        return ReliableTxtDecoder.decode(bytes);
    }
    async appendText(text) {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canWrite) {
            throw new Error(`Not a writer`);
        }
        const fileSize = await this.getSize();
        const bytes = ReliableTxtEncoder.encodePart(text, this.encoding);
        const result = await this.handle.write(bytes, 0, bytes.length, fileSize);
        if (result.bytesWritten !== bytes.length) {
            throw new Error(`Text was not fully written`);
        }
    }
    async readBytes(buffer, offset, length, position = null) {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canRead) {
            throw new Error(`Not a reader`);
        }
        const result = await this.handle.read(buffer, offset, length, position);
        return result.bytesRead;
    }
    async truncate(goalLength) {
        if (this.handle === null) {
            throw new Error(`File handle closed`);
        }
        if (!this.canWrite) {
            throw new Error(`Not a writer`);
        }
        if (goalLength < this.preambleSize) {
            throw new Error("New file length cannot be smaller than the preamble size");
        }
        await this.handle.truncate(goalLength);
    }
    async close() {
        if (this.handle !== null) {
            await this.handle.close();
            this.handle = null;
        }
    }
    static async createReader(filePath) {
        const handle = await fs.promises.open(filePath, "r");
        try {
            const encoding = await this.getEncodingOrNull(handle);
            if (encoding === null) {
                throw new NoReliableTxtPreambleError();
            }
            return new ReliableTxtFileHandle(handle, encoding, 0, true);
        }
        catch (error) {
            await handle.close();
            throw error;
        }
    }
    static async createWriter(filePath, encoding = ReliableTxtEncoding.Utf8, overwriteExisting = true) {
        const handle = await fs.promises.open(filePath, overwriteExisting ? "w" : "wx");
        try {
            const preambleBytes = ReliableTxtEncodingUtil.getPreambleBytes(encoding);
            const result = await handle.write(preambleBytes, 0, preambleBytes.length, 0);
            if (result.bytesWritten !== preambleBytes.length) {
                throw new Error(`Preamble was not fully written`);
            }
            return new ReliableTxtFileHandle(handle, encoding, 1, false);
        }
        catch (error) {
            await handle.close();
            throw error;
        }
    }
    static async createAppender(filePath, createWithEncoding = ReliableTxtEncoding.Utf8) {
        try {
            const handle = await fs.promises.open(filePath, "r+");
            try {
                const encoding = await this.getEncodingOrNull(handle);
                if (encoding === null) {
                    throw new NoReliableTxtPreambleError();
                }
                return new ReliableTxtFileHandle(handle, encoding, 2, true);
            }
            catch (error) {
                await handle.close();
                throw error;
            }
        }
        catch (error) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (error.code === "ENOENT") {
                return await this.createWriter(filePath, createWithEncoding, false);
            }
            else {
                throw error;
            }
        }
    }
    static async getEncodingOrNull(handle) {
        let buffer = new Uint8Array(4);
        const result = await handle.read(buffer, 0, 4, 0);
        buffer = buffer.slice(0, result.bytesRead);
        return ReliableTxtDecoder.getEncodingOrNull(buffer);
    }
}
// ----------------------------------------------------------------------
export class ReliableTxtFile {
    static loadSync(filePath) {
        const handle = SyncReliableTxtFileHandle.createReader(filePath);
        try {
            return handle.getDocument();
        }
        finally {
            handle.close();
        }
    }
    static async load(filePath) {
        const handle = await ReliableTxtFileHandle.createReader(filePath);
        try {
            return await handle.getDocument();
        }
        finally {
            await handle.close();
        }
    }
    static readAllTextSync(filePath) {
        return this.loadSync(filePath).text;
    }
    static async readAllText(filePath) {
        const document = await this.load(filePath);
        return document.text;
    }
    static readAllLinesSync(filePath) {
        return this.loadSync(filePath).getLines();
    }
    static async readAllLines(filePath) {
        const document = await this.load(filePath);
        return document.getLines();
    }
    static saveSync(document, filePath, overwriteExisting = true) {
        const handle = SyncReliableTxtFileHandle.createWriter(filePath, document.encoding, overwriteExisting);
        try {
            handle.appendText(document.text);
        }
        finally {
            handle.close();
        }
    }
    static async save(document, filePath, overwriteExisting = true) {
        const handle = await ReliableTxtFileHandle.createWriter(filePath, document.encoding, overwriteExisting);
        try {
            await handle.appendText(document.text);
        }
        finally {
            handle.close();
        }
    }
    static writeAllTextSync(content, filePath, encoding = ReliableTxtEncoding.Utf8, overwriteExisting = true) {
        const document = new ReliableTxtDocument(content, encoding);
        this.saveSync(document, filePath, overwriteExisting);
    }
    static async writeAllText(content, filePath, encoding = ReliableTxtEncoding.Utf8, overwriteExisting = true) {
        const document = new ReliableTxtDocument(content, encoding);
        await this.save(document, filePath, overwriteExisting);
    }
    static writeAllLinesSync(lines, filePath, encoding = ReliableTxtEncoding.Utf8, overwriteExisting = true) {
        const document = ReliableTxtDocument.fromLines(lines, encoding);
        this.saveSync(document, filePath, overwriteExisting);
    }
    static async writeAllLines(lines, filePath, encoding = ReliableTxtEncoding.Utf8, overwriteExisting = true) {
        const document = ReliableTxtDocument.fromLines(lines, encoding);
        await this.save(document, filePath, overwriteExisting);
    }
    static appendSync(content, filePath, createWithEncoding, prependLineBreakIfNotEmpty) {
        const handle = SyncReliableTxtFileHandle.createAppender(filePath, createWithEncoding);
        try {
            const isEmpty = handle.getIsEmpty();
            if (prependLineBreakIfNotEmpty && !isEmpty) {
                content = "\n" + content;
            }
            handle.appendText(content);
        }
        finally {
            handle.close();
        }
    }
    static async append(content, filePath, createWithEncoding, prependLineBreakIfNotEmpty) {
        const handle = await ReliableTxtFileHandle.createAppender(filePath, createWithEncoding);
        try {
            const isEmpty = await handle.getIsEmpty();
            if (prependLineBreakIfNotEmpty && !isEmpty) {
                content = "\n" + content;
            }
            await handle.appendText(content);
        }
        finally {
            await handle.close();
        }
    }
    static appendAllTextSync(content, filePath, createWithEncoding = ReliableTxtEncoding.Utf8) {
        this.appendSync(content, filePath, createWithEncoding, false);
    }
    static async appendAllText(content, filePath, createWithEncoding = ReliableTxtEncoding.Utf8) {
        await this.append(content, filePath, createWithEncoding, false);
    }
    static appendAllLinesSync(lines, filePath, createWithEncoding = ReliableTxtEncoding.Utf8) {
        const content = ReliableTxtLines.join(lines);
        this.appendSync(content, filePath, createWithEncoding, true);
    }
    static async appendAllLines(lines, filePath, createWithEncoding = ReliableTxtEncoding.Utf8) {
        const content = ReliableTxtLines.join(lines);
        await this.append(content, filePath, createWithEncoding, true);
    }
}
// ----------------------------------------------------------------------
export class SyncReliableTxtStreamReader {
    get isClosed() {
        return this.handle.isClosed;
    }
    get encoding() {
        return this.handle.encoding;
    }
    constructor(handle, chunkSize) {
        this.rest = new Uint8Array(0);
        if (chunkSize < 2) {
            throw new RangeError("Chunk size too small");
        }
        this.buffer = new Uint8Array(chunkSize);
        this.handle = handle;
        if (handle.encoding !== ReliableTxtEncoding.Utf8) {
            throw new Error("Not implemented");
        }
        this.position = handle.preambleSize;
    }
    static create(filePath, chunkSize = 4096) {
        const handle = SyncReliableTxtFileHandle.createReader(filePath);
        try {
            return new SyncReliableTxtStreamReader(handle, chunkSize);
        }
        catch (error) {
            handle.close();
            throw error;
        }
    }
    static getAppendReader(handle, chunkSize = 4096) {
        if (!handle.existing) {
            throw new Error(`File handle is not in append mode`);
        }
        return new SyncReliableTxtStreamReader(handle, chunkSize);
    }
    readLine() {
        if (this.handle.isClosed) {
            throw new Error("Stream reader is closed");
        }
        if (this.rest === null) {
            return null;
        }
        let lastStartIndex = 0;
        let current = this.rest;
        for (;;) {
            const newlineIndex = current.indexOf(0x0A, lastStartIndex);
            if (newlineIndex >= 0) {
                const lineBytes = current.slice(0, newlineIndex);
                const lineStr = ReliableTxtDecoder.decodePart(lineBytes, this.encoding);
                this.rest = current.slice(newlineIndex + 1);
                return lineStr;
            }
            else {
                lastStartIndex = current.length;
                const numBytesRead = this.handle.readBytes(this.buffer, 0, this.buffer.length, this.position);
                if (numBytesRead === 0) {
                    const lineStr = ReliableTxtDecoder.decodePart(current, this.encoding);
                    this.rest = null;
                    return lineStr;
                }
                this.position += numBytesRead;
                const newCurrent = new Uint8Array(current.length + numBytesRead);
                newCurrent.set(current, 0);
                if (numBytesRead < this.buffer.length) {
                    newCurrent.set(this.buffer.subarray(0, numBytesRead), current.length);
                }
                else {
                    newCurrent.set(this.buffer, current.length);
                }
                current = newCurrent;
            }
        }
    }
    close() {
        this.handle.close();
    }
}
// ----------------------------------------------------------------------
export class ReliableTxtStreamReader {
    get isClosed() {
        return this.handle.isClosed;
    }
    get encoding() {
        return this.handle.encoding;
    }
    constructor(handle, chunkSize) {
        this.rest = new Uint8Array(0);
        if (chunkSize < 2) {
            throw new RangeError("Chunk size too small");
        }
        this.buffer = new Uint8Array(chunkSize);
        this.handle = handle;
        if (handle.encoding !== ReliableTxtEncoding.Utf8) {
            throw new Error("Not implemented");
        }
        this.position = handle.preambleSize;
    }
    static async create(filePath, chunkSize = 4096) {
        const handle = await ReliableTxtFileHandle.createReader(filePath);
        try {
            return new ReliableTxtStreamReader(handle, chunkSize);
        }
        catch (error) {
            await handle.close();
            throw error;
        }
    }
    static getAppendReader(handle, chunkSize = 4096) {
        if (!handle.existing) {
            throw new Error(`File handle is not in append mode`);
        }
        return new ReliableTxtStreamReader(handle, chunkSize);
    }
    async readLine() {
        if (this.handle.isClosed) {
            throw new Error("Stream reader is closed");
        }
        if (this.rest === null) {
            return null;
        }
        let lastStartIndex = 0;
        let current = this.rest;
        for (;;) {
            const newlineIndex = current.indexOf(0x0A, lastStartIndex);
            if (newlineIndex >= 0) {
                const lineBytes = current.slice(0, newlineIndex);
                const lineStr = ReliableTxtDecoder.decodePart(lineBytes, this.encoding);
                this.rest = current.slice(newlineIndex + 1);
                return lineStr;
            }
            else {
                lastStartIndex = current.length;
                const numBytesRead = await this.handle.readBytes(this.buffer, 0, this.buffer.length, this.position);
                if (numBytesRead === 0) {
                    const lineStr = ReliableTxtDecoder.decodePart(current, this.encoding);
                    this.rest = null;
                    return lineStr;
                }
                this.position += numBytesRead;
                const newCurrent = new Uint8Array(current.length + numBytesRead);
                newCurrent.set(current, 0);
                if (numBytesRead < this.buffer.length) {
                    newCurrent.set(this.buffer.subarray(0, numBytesRead), current.length);
                }
                else {
                    newCurrent.set(this.buffer, current.length);
                }
                current = newCurrent;
            }
        }
    }
    async close() {
        await this.handle.close();
    }
}
// ----------------------------------------------------------------------
export var WriterMode;
(function (WriterMode) {
    WriterMode[WriterMode["Create"] = 0] = "Create";
    WriterMode[WriterMode["CreateOrOverwrite"] = 1] = "CreateOrOverwrite";
    WriterMode[WriterMode["CreateOrAppend"] = 2] = "CreateOrAppend";
})(WriterMode || (WriterMode = {}));
// ----------------------------------------------------------------------
export class SyncReliableTxtStreamWriter {
    get isClosed() {
        return this.handle.isClosed;
    }
    get encoding() {
        return this.handle.encoding;
    }
    get existing() {
        return this.handle.existing;
    }
    constructor(handle, isEmpty) {
        this.handle = handle;
        this.isEmpty = isEmpty;
    }
    static create(filePath, createWithEncoding = ReliableTxtEncoding.Utf8, mode = WriterMode.CreateOrOverwrite) {
        if (mode === WriterMode.CreateOrAppend) {
            const handle = SyncReliableTxtFileHandle.createAppender(filePath, createWithEncoding);
            try {
                const isEmpty = handle.getIsEmpty();
                return new SyncReliableTxtStreamWriter(handle, isEmpty);
            }
            catch (error) {
                handle.close();
                throw error;
            }
        }
        else {
            const overwriteExisting = mode === WriterMode.CreateOrOverwrite;
            const handle = SyncReliableTxtFileHandle.createWriter(filePath, createWithEncoding, overwriteExisting);
            try {
                return new SyncReliableTxtStreamWriter(handle, true);
            }
            catch (error) {
                handle.close();
                throw error;
            }
        }
    }
    write(text) {
        if (this.handle.isClosed) {
            throw new Error("Stream writer is closed");
        }
        if (text.length === 0) {
            return;
        }
        else {
            this.isEmpty = false;
        }
        this.handle.appendText(text);
    }
    writeLine(line) {
        if (!this.isEmpty) {
            line = "\n" + line;
        }
        if (line.length === 0) {
            this.isEmpty = false;
        }
        this.write(line);
    }
    writeLines(lines) {
        for (const line of lines) {
            this.writeLine(line);
        }
    }
    internalTruncate(goalLength) {
        if (this.handle.isClosed) {
            throw new Error("Stream writer is closed");
        }
        this.handle.truncate(goalLength);
    }
    close() {
        this.handle.close();
    }
}
// ----------------------------------------------------------------------
export class ReliableTxtStreamWriter {
    get isClosed() {
        return this.handle.isClosed;
    }
    get encoding() {
        return this.handle.encoding;
    }
    get existing() {
        return this.handle.existing;
    }
    constructor(handle, isEmpty) {
        this.handle = handle;
        this.isEmpty = isEmpty;
    }
    static async create(filePath, createWithEncoding = ReliableTxtEncoding.Utf8, mode = WriterMode.CreateOrOverwrite) {
        if (mode === WriterMode.CreateOrAppend) {
            const handle = await ReliableTxtFileHandle.createAppender(filePath, createWithEncoding);
            try {
                const isEmpty = await handle.getIsEmpty();
                return new ReliableTxtStreamWriter(handle, isEmpty);
            }
            catch (error) {
                await handle.close();
                throw error;
            }
        }
        else {
            const overwriteExisting = mode === WriterMode.CreateOrOverwrite;
            const handle = await ReliableTxtFileHandle.createWriter(filePath, createWithEncoding, overwriteExisting);
            try {
                return new ReliableTxtStreamWriter(handle, true);
            }
            catch (error) {
                await handle.close();
                throw error;
            }
        }
    }
    async write(text) {
        if (this.handle.isClosed) {
            throw new Error("Stream writer is closed");
        }
        if (text.length === 0) {
            return;
        }
        else {
            this.isEmpty = false;
        }
        await this.handle.appendText(text);
    }
    async writeLine(line) {
        if (!this.isEmpty) {
            line = "\n" + line;
        }
        if (line.length === 0) {
            this.isEmpty = false;
        }
        await this.write(line);
    }
    async writeLines(lines) {
        for (const line of lines) {
            await this.writeLine(line);
        }
    }
    async internalTruncate(goalLength) {
        if (this.handle.isClosed) {
            throw new Error("Stream writer is closed");
        }
        await this.handle.truncate(goalLength);
    }
    async close() {
        await this.handle.close();
    }
}
// ----------------------------------------------------------------------
export class SyncReverseLineIterator {
    constructor(handle, position) {
        this.buffer = new Uint8Array(128);
        this.handle = handle;
        this.position = position;
    }
    static create(handle) {
        if (handle.encoding !== ReliableTxtEncoding.Utf8) {
            throw new Error("Not implemented");
        }
        const position = handle.getSize() - 1;
        return new SyncReverseLineIterator(handle, position);
    }
    getLine() {
        const start = Math.max(this.position - this.buffer.length + 1, 0);
        const length = this.position - start + 1;
        const numBytesRead = this.handle.readBytes(this.buffer, 0, length, start);
        if (numBytesRead !== length) {
            throw new Error("Not supported");
        }
        for (let i = length - 1; i >= 0; i--) {
            const currentByte = this.buffer[i];
            if (currentByte === 0x0A) {
                this.position = start + i - 1;
                const sliceStart = i + 1;
                const sliceLength = length - i - 1;
                const lineBytes = this.buffer.slice(sliceStart, sliceStart + sliceLength);
                return Utf16String.fromUtf8Bytes(lineBytes, false);
            }
        }
        throw new Error("Not implemented"); // TODO
    }
    getPosition() {
        return this.position;
    }
}
// ----------------------------------------------------------------------
export class ReverseLineIterator {
    constructor(handle, position) {
        this.buffer = new Uint8Array(128);
        this.handle = handle;
        this.position = position;
    }
    static async create(handle) {
        if (handle.encoding !== ReliableTxtEncoding.Utf8) {
            throw new Error("Not implemented");
        }
        const position = await handle.getSize() - 1;
        return new ReverseLineIterator(handle, position);
    }
    async getLine() {
        const start = Math.max(this.position - this.buffer.length + 1, 0);
        const length = this.position - start + 1;
        const numBytesRead = await this.handle.readBytes(this.buffer, 0, length, start);
        if (numBytesRead !== length) {
            throw new Error("Not supported");
        }
        for (let i = length - 1; i >= 0; i--) {
            const currentByte = this.buffer[i];
            if (currentByte === 0x0A) {
                this.position = start + i - 1;
                const sliceStart = i + 1;
                const sliceLength = length - i - 1;
                const lineBytes = this.buffer.slice(sliceStart, sliceStart + sliceLength);
                return Utf16String.fromUtf8Bytes(lineBytes, false);
            }
        }
        throw new Error("Not implemented"); // TODO
    }
    getPosition() {
        return this.position;
    }
}
//# sourceMappingURL=reliabletxt-io.js.map